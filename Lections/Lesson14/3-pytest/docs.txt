Кейсов всего два: test_first_num и test_first_chr. И каждый из них использует свои
фикстуры. Но давайте обо всём сверху вниз.
➢ Фикстура get_file
Фикстура принимает на вход аргумент tmp_path. Это встроенная фикстура, которая
возвращает временный путь - объект pathlib.Path. При использовании выводим не
печать информацию о создании файла и о его удалении. Отследим когда
срабатывает фикстура.
Внутри менеджера контекста создаём файл и через команду yield возвращаем
указатель на него. Если бы мы использовали команду return, менеджер контекста
вызвал бы f.close() после возврата указания и файл стал бы нечитаемым.
Используя yield мы превратили функцию в генератор. Теперь внутри фикстуры есть
“сетап” создающий файл и “тирдаун”, закрывающий его после использования.
Внимание! Мы явно не удаляем временные файлы. Фикстура tmp_path сохраняет
три последних временных каталога, удаляя старые при очередном запуске.
➢ Фикстура set_num
Используя файловый дескриптор get_file записываем строку из цифр и возвращаем
указатель на начало файла. Фикстура ничего не возвращает.
➢ Фикстура set_char
Снова используем файловый дескриптор get_file, но получаем уже другой файл. Имя
совпадает, но каталоги разные. Заполняем его буквами, сбрасываем позицию в
ноль и возвращаем get_file - файловый дескриптор.
➢ Кейс test_first_num
Перед началом теста срабатывают фикстуры, создающие временный файл и
заполняющие его цифрами. Далее обращаемся к get_file чтобы прочитать пять
первых символов и сравниваем их со строкой текста.
➢ Кейс test_first_char
Кейс получает всего одну фикстуру set_char. Но так как она самостоятельно
вызывает фикстуру get_file и возвращает её, мы можем обращаться к файловому
дескриптору по имени set_char.
Рассмотренный пример даёт представление о гибкости кейсов pytest.
Субъективное мнение автора курса, но pytest является лучшим из трёх
рассмотренных инструментов тестирования. Попробуйте все три, составьте своё.
